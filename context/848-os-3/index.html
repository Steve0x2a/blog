<!DOCTYPE html>
<html lang='en' ><meta charset="utf-8">
<meta name="viewport" content="width=device-width">


<title>848操作系统(三) 内存管理 | 0x2a&#39;s blog</title>

<meta name="generator" content="Hugo Eureka 0.8.3-dev" />
<link rel="stylesheet" href="https://0x2a.in/blog/css/eureka.min.css">
<script defer src="https://0x2a.in/blog/js/eureka.min.js"></script>

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload"
  href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap"
  as="style" onload="this.onload=null;this.rel='stylesheet'">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/styles/atom-one-dark.min.css"
   media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/highlight.min.js"
   crossorigin></script>

  <script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/languages/[python%20c%20go%20c&#43;&#43;%20shell%20js].min.js"
     crossorigin></script>

<script defer src="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/js/all.min.js"
   integrity="sha256-uNYoXefWRqv&#43;PsIF/OflNmwtKM4lStn9yrz2gVl6ymo="  crossorigin></script>




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
   integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3&#43;Aro6EYUG4&#43;cU&#43;KJWu/X"  media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" 
  integrity="sha384-g7c&#43;Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI&#43;sEnkvrMWph2EDg4"  crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
   integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC&#43;Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa"  crossorigin></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true }
      ],
    });
  });
</script>


<script defer src="https://cdn.jsdelivr.net/npm/mermaid@8.9.2/dist/mermaid.min.js" 
  integrity="sha256-Zmpaaj&#43;GXFsPF5WdPArSrnW3b30dovldeKsW00xBVwE="  crossorigin></script>


<link rel="icon" type="image/png" sizes="32x32" href="https://0x2a.in/blog/images/icon_hudd51a6aca11f958e5ee26ffb845389b9_13185_32x32_fill_box_center_3.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://0x2a.in/blog/images/icon_hudd51a6aca11f958e5ee26ffb845389b9_13185_180x180_fill_box_center_3.png">

<meta name="description"
  content="内存管理 内存管理基础 内存管理概念 内存管理功能: 内存空间分配和回收 地址转换 内存空间扩充 存储保护 程序装入与链接 用户程序要在系统中运行，必须先装入内存，一般">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
      "@type": "ListItem",
      "position": 1 ,
      "name":"Contexts",
      "item":"https://0x2a.in/blog/context/"},{
      "@type": "ListItem",
      "position": 2 ,
      "name":"848操作系统(三) 内存管理",
      "item":"https://0x2a.in/blog/context/848-os-3/"}]
}
</script>



<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://0x2a.in/blog/context/848-os-3/"
    },
    "headline": "848操作系统(三) 内存管理 | 0x2a\u0027s blog","datePublished": "2020-09-25T20:39:15+00:00",
    "dateModified": "2020-09-25T20:39:15+00:00",
    "wordCount":  3119 ,
    "publisher": {
        "@type": "Person",
        "name":  42 ,
        "logo": {
            "@type": "ImageObject",
            "url": "https://0x2a.in/blog/images/icon.png"
        }
        },
    "description": "内存管理 内存管理基础 内存管理概念 内存管理功能: 内存空间分配和回收 地址转换 内存空间扩充 存储保护 程序装入与链接 用户程序要在系统中运行，必须先装入内存，一般"
}
</script><meta property="og:title" content="848操作系统(三) 内存管理 | 0x2a&#39;s blog" />
<meta property="og:type" content="article" />


<meta property="og:image" content="https://0x2a.in/blog/images/icon.png">


<meta property="og:url" content="https://0x2a.in/blog/context/848-os-3/" />




<meta property="og:description" content="内存管理 内存管理基础 内存管理概念 内存管理功能: 内存空间分配和回收 地址转换 内存空间扩充 存储保护 程序装入与链接 用户程序要在系统中运行，必须先装入内存，一般" />




<meta property="og:locale" content="en" />




<meta property="og:site_name" content="0x2a&#39;s blog" />






<meta property="article:published_time" content="2020-09-25T20:39:15&#43;00:00" />


<meta property="article:modified_time" content="2020-09-25T20:39:15&#43;00:00" />



<meta property="article:section" content="context" />


<meta property="article:tag" content="操作系统" />

<meta property="article:tag" content="考研" />





<meta property="og:see_also" content="https://0x2a.in/blog/context/848-os-2/" />

<meta property="og:see_also" content="https://0x2a.in/blog/context/848-os-1/" />

<meta property="og:see_also" content="https://0x2a.in/blog/context/848-ds-2/" />

<meta property="og:see_also" content="https://0x2a.in/blog/context/848-ds-1/" />

<meta property="og:see_also" content="https://0x2a.in/blog/posts/2021-848/" />



<body class="flex flex-col min-h-screen">
  <header class="fixed flex items-center w-full min-h-16 pl-scrollbar z-50 bg-secondary-bg shadow-sm">
    <div class="w-full max-w-screen-xl mx-auto"><script>
    let storageColorScheme = localStorage.getItem("lightDarkMode")
    if (((storageColorScheme == 'Auto' || storageColorScheme == null) && window.matchMedia("(prefers-color-scheme: dark)").matches) || storageColorScheme == "Dark") {
        document.getElementsByTagName('html')[0].classList.add('dark')
    }
</script>
<nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0">
    <a href="/blog/" class="mr-6 text-primary-text text-xl font-bold">0x2a&#39;s blog</a>
    <button id="navbar-btn" class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
        <i class="fas fa-bars"></i>
    </button>

    <div id="target"
        class="hidden block md:flex md:flex-grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
        <div class="md:flex md:h-16 text-sm md:flex-grow pb-4 md:pb-0 border-b md:border-b-0">
            <a href="/blog/about/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  mr-4">About</a>
            <a href="/blog/posts/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  mr-4">Posts</a>
            <a href="/blog/tags/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  mr-4">Tags</a>
        </div>

        <div class="flex">
            <div class="relative pt-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="lightDarkMode">
                    <i class="fas fa-adjust"></i>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open">
                </div>
                <div class="absolute flex flex-col left-0 md:left-auto right-auto md:right-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='lightDarkOptions'>
                    <span class="px-4 py-1 hover:text-eureka" name="Light">Light</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Dark">Dark</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Auto">Auto</span>
                </div>
            </div>
        </div>
    </div>

    <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id="is-open-mobile">
    </div>

</nav>
<script>
    
    let element = document.getElementById('lightDarkMode')
    if (storageColorScheme == null || storageColorScheme == 'Auto') {
        document.addEventListener('DOMContentLoaded', () => {
            window.matchMedia("(prefers-color-scheme: dark)").addEventListener('change', switchDarkMode)
        })
    } else if (storageColorScheme == "Light") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'sun')
        element.firstElementChild.classList.add('fa-sun')
    } else if (storageColorScheme == "Dark") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'moon')
        element.firstElementChild.classList.add('fa-moon')
    }

    document.addEventListener('DOMContentLoaded', () => {
        getcolorscheme();
        switchBurger();
    });
</script>
</div>
  </header>
  <main class="flex-grow pt-16">
    <div class="pl-scrollbar">
      <div class="w-full max-w-screen-xl lg:px-4 xl:px-8 mx-auto">


<div class="grid grid-cols-2 lg:grid-cols-8 gap-4 lg:pt-12">
    <div
        class="col-span-2  lg:col-span-6 bg-secondary-bg rounded px-6 py-8">
        <h1 class="font-bold text-3xl text-primary-text">848操作系统(三) 内存管理</h1>
        <div class="flex flex-wrap flex-row items-center mt-2 text-tertiary-text">
    <div class="mr-6 my-2">
        <i class="fas fa-calendar mr-1"></i>
        <span>2020-09-25</span>
    </div>
    <div class="mr-6 my-2">
        <i class="fas fa-clock mr-1"></i>
        <span>7 min read</span>
    </div>
    
    

    
</div>
        
        
        

        <div class="content">
            <h1 id="内存管理">内存管理</h1>
<h2 id="内存管理基础">内存管理基础</h2>
<h3 id="内存管理概念">内存管理概念</h3>
<p>内存管理功能:</p>
<ol>
<li>内存空间分配和回收</li>
<li>地址转换</li>
<li>内存空间扩充</li>
<li>存储保护</li>
</ol>
<h4 id="程序装入与链接">程序装入与链接</h4>
<p>用户程序要在系统中运行，必须先装入内存，一般有如下步骤：</p>
<ol>
<li>编译</li>
<li>链接</li>
<li>装入</li>
</ol>
<p>链接有以下几种方式：</p>
<ol>
<li>静态链接
运行之前就把目标模块以及库函数连接成一个完整的装配模块，不再拆开。这种方式需要解决两个问题：
<ul>
<li>对相对地址的修改</li>
<li>变换外部调用符号</li>
</ul>
</li>
<li>装入时动态链接
装入内存的时候再进行链接。</li>
<li>运行时动态链接
运行的时候需要该模块再调进内存并连接。</li>
</ol>
<p>装入有以下方式：</p>
<ol>
<li>绝对装入方式
装入的是绝对地址，一般适用于单道程序的环境。</li>
<li>可重定位装入方式
装入的相对地址，装入时对目标程序指令和数据修改的过程叫<strong>重定位</strong>。
地址通常是装入时一次完成的，故也称为静态重定位。一旦作业装入内存，则必须分配要求的所有内存空间。（毕竟要给所有指令和数据编址）故又称为静态重定位。</li>
<li>动态运行时装入
也成为动态重定位。程序装入内存后，并不把所有地址都转换成绝对地址，而是推迟到程序真正要执行的时候才执行重定位。这种方式需要一个重定位寄存器实现。</li>
</ol>
<h4 id="逻辑地址与物理地址空间">逻辑地址与物理地址空间</h4>
<p>逻辑地址指的是编译后每个模块都从0开始的<strong>相对地址</strong>。
物理地址空间指的是内存中的物理党员集合。是地址转换的<strong>最终地址</strong>，最后都要根据物理地址从主存中获得数据。</p>
<h4 id="内存保护">内存保护</h4>
<p>内存保护一般可以采用两种方法</p>
<ol>
<li>设置一对上下限寄存器
每当CPU要访问一个地址时，将该地址和寄存器的值进行对比。</li>
<li>使用重定位寄存器和界地址寄存器
重定位寄存器存储的是最小的物理地址值，界地址寄存器存储的是逻辑地址的最大值。
对于CPU要访问的地址先和界地址值比对，如果符合要求再加上重定位寄存器的值获得物理地址。</li>
</ol>
<h3 id="交换与覆盖">交换与覆盖</h3>
<p>交换主要是用作与多道程序，覆盖用作于单道程序。
交换中的交换空间通常作为磁盘的一整块，且独立于文件系统。</p>
<h3 id="连续分配管理方式">连续分配管理方式</h3>
<h4 id="单一连续分配">单一连续分配</h4>
<p>这种方式会分为系统区和用户区，这种方式不需要内存保护，但同时只能给单个程序使用。<strong>有内部碎片 无外部碎片</strong></p>
<h4 id="固定分区连续">固定分区连续</h4>
<p>又根据分区大小是否相等分为两种。需要一张内存分区表，程序需要转入时，查询表是否有可用内存，无法满足则不分配内存。
<strong>有内部碎片 无外部碎片</strong></p>
<h4 id="动态分区分配">动态分区分配</h4>
<p>主要分为四种：</p>
<ol>
<li>首次适应算法。总体效果最好</li>
<li>最佳适应算法。会产生最多的外部碎片</li>
<li>最坏适应算法。又称最大适应，对大程序不友好。</li>
<li>临近适应。</li>
</ol>
<h3 id="非连续分配管理方式">非连续分配管理方式</h3>
<h4 id="分页管理方式">分页管理方式</h4>
<p>分页管理方式<strong>没有外部碎片，有内部碎片</strong>
分页存储的几个概念</p>
<ol>
<li>页面和页面大小
<strong>进程</strong>中的块称为<strong>页</strong>，<strong>内存</strong>中的块称为<strong>页框</strong>，外存的块就成为块。
进程执行的时候会申请空间，对应着页和页框。</li>
<li>地址结构
地质结构包含<strong>页号和页内偏移量</strong>。</li>
<li>页表
<strong>每个进程</strong>拥有一个页表。页表一般存放在内存。</li>
</ol>
<p>PTR 每个系统只有一个。记录页表开始地址和长度。
快表就是在高速缓存存储器中存一部分的页表拷贝，可以提速。快表找不到再去页表找。当然有些系统快慢一起找，快表找到了就停止慢表的查找。</p>
<h4 id="分段管理方式">分段管理方式</h4>
<p>段式管理结构根据用户进程的自然段划分逻辑空间。段内要求地址连续，段间不要求连续。
每个进程都有一张逻辑空间与内存映射的段表，记录着段号、段长、以及本段在主存的起址。</p>
<p>分段式管理方式有以下优点：</p>
<ol>
<li>方便编程</li>
<li>信息共享</li>
<li>信息保护</li>
<li>动态增长</li>
<li>动态链接</li>
</ol>
<h4 id="段页式管理方式">段页式管理方式</h4>
<p>即将分段式和分页式结合，先将程序分成若干个段，再把每个段分为若干个页。
在段页式系统中，为了实现地址转换，需要同时配置段表和页表。和分段式不同的是，段表中记载的不是内存始址和段长，而是页表始址和页表长度。
在一个进程中，段表只有一个，页表可以有很多个（有多少段就多少个）</p>
<h2 id="虚拟内存管理">虚拟内存管理</h2>
<h3 id="虚拟内存的基本概念">虚拟内存的基本概念</h3>
<p>传统存储管理的特征：</p>
<ol>
<li>一次性</li>
<li>驻留性</li>
</ol>
<p>虚拟内存的特征：</p>
<ol>
<li>多次行</li>
<li>对换性</li>
<li>虚拟性</li>
</ol>
<h3 id="请求分页管理方式">请求分页管理方式</h3>
<p>请求分页系统的页表机制不同于基本分页系统，需要在页表中添加以下字段：</p>
<ol>
<li>状态位P：记录是否调入了内存</li>
<li>访问字段A：记录一段时间内被访问的次数</li>
<li>修改位M：记录是否被修改过</li>
<li>外存地址：记录在外存上的地址</li>
</ol>
<h3 id="页面置换算法">页面置换算法</h3>
<h4 id="最佳opt置换算法">最佳（OPT）置换算法</h4>
<p>被调出的是<strong>最长时间内不被调用的</strong>页面。但是无法预测未来时间的调用，因此无法实现。</p>
<p>####先进先出（FIFO）置换算法
优先淘汰<strong>最早装进内存</strong>的页面。
FIFO算法还会导致<strong>Belady</strong>异常，即分配的物理块增大，反而导致缺页故障变多的现象。
基于队列实现。</p>
<h4 id="最近最久未使用lru算法">最近最久未使用（LRU）算法</h4>
<p>选择<strong>最久未使用</strong>的算法进行淘汰。性能较好，但需要堆栈支持。</p>
<h4 id="时钟clock算法">时钟（CLOCK）算法</h4>
<p>时钟算法又称最近未用（NRU）算法。
简单的Clock算法只附加一个位：使用位。当某页首次装入内存时，将它使用位置为1，当该页再次被访问时，依旧置为1。需要页面置换的时候，操作系统扫描缓冲区，寻找使用位为0的页面，经过使用位为1的页面时，也会将使用位置0。</p>
<p>改进的Clock算法增加一个修改位，对于被修改过的页来说，需要重新写回到磁盘，而未修改过的页面不需要写回磁盘。那么修改过的页面置换代价更大，因此<strong>优先换出未修改过的页面</strong>
那么每一帧都会处于以下时钟状态之一：</p>
<ol>
<li>未被访问，未被修改（A=0，M=0）<strong>最佳替换页</strong></li>
<li>未被访问，已被修改（A=0，M=1）不算特别好的置换页</li>
<li>已被访问，未被修改（A=1，M=0），有可能被访问</li>
<li>已被访问，且被修改（A=1，M=1），可能被访问</li>
</ol>
<p>这里可以看到的是，访问的优先级会比修改高，最近被访问的页面会偏向于不被换出，然后到未被访问但修改过的页面，最易于被换出的是未被访问未被修改。总体的步骤如下：</p>
<ol>
<li>寻找A=0，M=0的页面，不修改任何标志位</li>
<li>寻找A=0，M=1的页面，将A=1的页面修改为A=0。</li>
<li>重复1 - 2</li>
</ol>
<h3 id="页面分配策略">页面分配策略</h3>
<h4 id="驻留集大小">驻留集大小</h4>
<p>决定驻留集大小需要考虑：</p>
<ol>
<li>分配给一个进程的存储越小，进程数目就越多，处理机使用率就越高</li>
<li>一个进程的页数越少，就会频繁缺页</li>
<li>页数过多，由于局部性原则，可能并不会提高太多的缺页率。
基于上述考虑，内存分配策略有以下几种：</li>
<li>固定分配局部替换
为每个进程分配一定数目的物理块，整个过程不变，如果缺页只能用自己的页面进行换出。这样的策略难点在于缺点固定分配的数目大小。</li>
<li>可变分配全局置换
最容易实现的分配策略。为进程分配一定数量的物理块，同时也保留一部分空闲的物理块队列。缺页时，从空闲物理块分配给进程。</li>
<li>可变分配局部替换
为每个进程分配一定数量的物理块，缺页时只能用自己的页面进行置换，<strong>频繁</strong>缺页操作系统则给他分配物理块，直至缺页率正常。反之，如果物理块过多，也会被剥削。</li>
</ol>
<h4 id="调入页面的时机">调入页面的时机</h4>
<p>有两种调入策略：</p>
<ol>
<li>预调页策略
根据局部性原理，一次调度若干相邻页会比一次次调入更为高效。目前策略主要为首次预调入，由程序员决定应该先调入哪些页。</li>
<li>请求调页策略
运行的时候需要的页面不在内存则提出请求。</li>
</ol>
<h4 id="从何处调入页面">从何处调入页面</h4>
<p>外存一般会被分为两部分：连续的对换区和离散的文件区。
因此，从何处调入页面就有了三种情况：</p>
<ol>
<li>系统拥有足够的对换区：直接全部从对换区调入</li>
<li>系统缺少足够的对换区：不会修改的文件从文件区调入，由于他们未被修改，换出的时候就不必换出来。对于被修改过的部分，则换出的时候放入对换区。</li>
<li>Unix方式：和进程有关的文件都放在文件区，未运行过的页面都从文件区调入，曾经运行过的但被调出的放入对换区，下次调入从对换区调入。</li>
</ol>
<h3 id="工作集">工作集</h3>
<p>工作集是指某段时间间隔内会访问到的页面集合。取决于窗口大小。
一般分配给进程的物理块数，要大于工作集大小。否则会出现抖动现象</p>
<h3 id="抖动">抖动</h3>
<p>刚被换出又要被换入，这种现象就叫做抖动。</p>
<h2 id="易错点">易错点</h2>
<ol>
<li>若进程在<strong>IO操作</strong>，不能交换操作</li>
<li>内存保护需要<strong>操作系统和硬件</strong>一起完成</li>
<li>重定位寄存器系统只需要一个</li>
<li>存储管理目的：方便用户、提高内存利用率</li>
<li>虚拟存储只能基于非连续分配技术</li>
<li>虚拟存储容量只受寻址空间影响</li>
<li>造成LRU算法耗费高的原因是需要对页进行排序，需要硬件支持只是前者导致的</li>
<li>合法位信息决定是否发生缺页故障</li>
<li>CPU使用率不高，外存使用率高，说明内存不够</li>
</ol>

        </div>
        
        <div class="my-4">
    
    <a href="https://0x2a.in/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka">#操作系统</a>
    
    <a href="https://0x2a.in/blog/tags/%E8%80%83%E7%A0%94/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka">#考研</a>
    
</div>
        
        
        


        
        
        
        
<div class="flex flex-col md:flex-row md:justify-between -mx-2 mt-4 px-2 pt-4 border-t">
    <div>
        
        <span class="block font-bold">Previous</span>
        <a href="https://0x2a.in/blog/context/848-os-4/" class="block">848操作系统(四) 文件管理</a>
        
    </div>
    <div class="md:text-right mt-4 md:mt-0">
        
        <span class="block font-bold">Next</span>
        <a href="https://0x2a.in/blog/context/848-os-2/" class="block">848操作系统(二) 进程管理</a>
        
    </div>
</div>

        



  <div id="valine-comments" class="mt-4"></div>
<script defer src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js" 
  integrity="sha256-fPqMAsW3FDt/rNyneSJ7HOpZNRs/O2rM016SU08JtCk="  crossorigin></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    new Valine({
      el: "#valine-comments",appId:"V4MDFNfytHcoabcly1MENtAo-gzGzoHsz",appKey:"xyl895MDJ2Q6BRDKwyRPr6xL",visitor:"true",
    })
  });
</script>

    </div>
    
    <div class="col-span-2">
        
        
        <div class="sticky top-16 z-10 hidden lg:block px-6 py-4  bg-primary-bg ">
    <span class="text-lg font-semibold">On This Page</span>
</div>
<div class="sticky-toc hidden lg:block px-6 pb-6 ">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#内存管理基础">内存管理基础</a>
      <ul>
        <li><a href="#内存管理概念">内存管理概念</a>
          <ul>
            <li><a href="#程序装入与链接">程序装入与链接</a></li>
            <li><a href="#逻辑地址与物理地址空间">逻辑地址与物理地址空间</a></li>
            <li><a href="#内存保护">内存保护</a></li>
          </ul>
        </li>
        <li><a href="#交换与覆盖">交换与覆盖</a></li>
        <li><a href="#连续分配管理方式">连续分配管理方式</a>
          <ul>
            <li><a href="#单一连续分配">单一连续分配</a></li>
            <li><a href="#固定分区连续">固定分区连续</a></li>
            <li><a href="#动态分区分配">动态分区分配</a></li>
          </ul>
        </li>
        <li><a href="#非连续分配管理方式">非连续分配管理方式</a>
          <ul>
            <li><a href="#分页管理方式">分页管理方式</a></li>
            <li><a href="#分段管理方式">分段管理方式</a></li>
            <li><a href="#段页式管理方式">段页式管理方式</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#虚拟内存管理">虚拟内存管理</a>
      <ul>
        <li><a href="#虚拟内存的基本概念">虚拟内存的基本概念</a></li>
        <li><a href="#请求分页管理方式">请求分页管理方式</a></li>
        <li><a href="#页面置换算法">页面置换算法</a>
          <ul>
            <li><a href="#最佳opt置换算法">最佳（OPT）置换算法</a></li>
            <li><a href="#最近最久未使用lru算法">最近最久未使用（LRU）算法</a></li>
            <li><a href="#时钟clock算法">时钟（CLOCK）算法</a></li>
          </ul>
        </li>
        <li><a href="#页面分配策略">页面分配策略</a>
          <ul>
            <li><a href="#驻留集大小">驻留集大小</a></li>
            <li><a href="#调入页面的时机">调入页面的时机</a></li>
            <li><a href="#从何处调入页面">从何处调入页面</a></li>
          </ul>
        </li>
        <li><a href="#工作集">工作集</a></li>
        <li><a href="#抖动">抖动</a></li>
      </ul>
    </li>
    <li><a href="#易错点">易错点</a></li>
  </ul>
</nav>
</div>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        enableStickyToc();
    });
</script>
        
    </div>
    

    
    
    <div
        class="col-span-2  lg:col-span-6 bg-secondary-bg rounded p-6">
        <h2 class="text-lg font-semibold mb-4">See Also</h2>
        <div class="content">
            
            <a href="https://0x2a.in/blog/context/848-os-2/">848操作系统(二) 进程管理</a>
            <br />
            
            <a href="https://0x2a.in/blog/context/848-os-1/">848操作系统(一) 操作系统概述</a>
            <br />
            
            <a href="https://0x2a.in/blog/context/848-ds-2/">848数据结构(二) 线性表</a>
            <br />
            
            <a href="https://0x2a.in/blog/context/848-ds-1/">848数据结构(一) 基本概念和术语</a>
            <br />
            
            <a href="https://0x2a.in/blog/posts/2021-848/">2021暨南大学848知识点总结</a>
            <br />
            
        </div>
    </div>
    
</div>
<script>
    document.addEventListener('DOMContentLoaded', ()=>{
        hljs.initHighlightingOnLoad();
    })
</script>

      </div>
    </div>
    
  </main>
  <footer class="pl-scrollbar">
    <div class="w-full max-w-screen-xl mx-auto"><div class="text-center p-6 pin-b">
    <p class="text-sm text-tertiary-text">&copy; 2021 <a href="https://0x2a.in/blog">0x2a</a>
 &middot;  Powered by the <a href="https://github.com/wangchucheng/hugo-eureka" class="hover:text-eureka">Eureka</a> theme for <a href="https://gohugo.io" class="hover:text-eureka">Hugo</a></p>
</div></div>
  </footer>
</body>

</html>